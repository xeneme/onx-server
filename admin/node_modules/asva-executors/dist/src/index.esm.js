import { __extends, __awaiter, __generator } from 'tslib';

var Executor = /** @class */ (function () {
    function Executor(command) {
        /**
         * Currently running commands
         */
        this.runCount = 0; //
        /**
         * Last executor run happened without an error
         */
        this.wasLastRunFine = false; //
        /**
         * Executor was run at least once
         */
        this.wasRun = false;
        /**
         * Executor was run without throwing error at least once
         */
        this.wasRunFine = false;
        /**
         * Executor was run with thrown error at least once
         */
        this.wasRunBad = false;
        this.command = command;
    }
    Executor.createAndRun = function (command) {
        var executor = new Executor(command);
        executor.run();
        return executor;
    };
    Object.defineProperty(Executor.prototype, "isRunning", {
        /**
         * Command from this executor is currently running.
         */
        get: function () {
            return !!this.runCount;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param parameters Arguments, will be passed down to command.
     * @returns {Promise<any>} Promise result is formed from whatever you returned from command.
     */
    Executor.prototype.run = function () {
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        this.beforeRun();
        var promise = this.command.apply(this, parameters);
        // NOTE This check was broken on second package import (package one < package two < executor)
        // if (!(promise instanceof Promise)) {
        //   throw new Error('Executor command should return promise.')
        // }
        this.afterRun(promise);
        return promise;
    };
    Executor.prototype.beforeRun = function () {
        this.runCount++;
    };
    Executor.prototype.afterRun = function (promise) {
        var _this = this;
        promise.then(function () {
            _this.runCount--;
            _this.setRunResultFlags(true);
        });
        promise.catch(function () {
            _this.runCount--;
            _this.setRunResultFlags(false);
        });
    };
    Executor.prototype.setRunResultFlags = function (success) {
        this.wasRun = true;
        this.wasLastRunFine = success;
        if (success) {
            this.wasRunFine = true;
        }
        if (!success) {
            this.wasRunBad = true;
        }
    };
    return Executor;
}());

/**
 * This executor caches first run result and provides it for all subsequent calls.
 */
var CacheExecutor = /** @class */ (function (_super) {
    __extends(CacheExecutor, _super);
    function CacheExecutor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.cachedPromise = null;
        return _this;
    }
    /**
     * Run command and cache promise.
     */
    CacheExecutor.prototype.run = function () {
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        if (!this.cachedPromise) {
            this.cachedPromise = _super.prototype.run.apply(this, parameters);
        }
        return this.cachedPromise;
    };
    /**
     * Run executor without cache. Promise will be put to cache though.
     */
    CacheExecutor.prototype.runFresh = function () {
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        this.cachedPromise = _super.prototype.run.apply(this, parameters);
        return this.cachedPromise;
    };
    /**
     * Just clean cache.
     */
    CacheExecutor.prototype.cleanCache = function () {
        this.cachedPromise = null;
    };
    return CacheExecutor;
}(Executor));

/**
 * This executor will chain requests ladder-like.
 * Last one will always be executed.
 * For skipped requests the promise will never be resolved.
 */
var LadderExecutor = /** @class */ (function (_super) {
    __extends(LadderExecutor, _super);
    function LadderExecutor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.trigger = null;
        return _this;
    }
    LadderExecutor.prototype.run = function () {
        var _this = this;
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        if (!this.isRunning) {
            var promise = _super.prototype.run.apply(this, parameters);
            promise.then(function () {
                _this.trigger && _this.trigger();
                _this.trigger = null;
            });
            return promise;
        }
        return new Promise(function (resolve) {
            _this.trigger = function () { return _this.run.apply(_this, parameters).then(resolve); };
        });
    };
    return LadderExecutor;
}(Executor));

/**
 * When you `run` executor - timer is set on timeout value and starts ticking down.
 * If you `run` before the timer is expired - timer is refreshed.
 * When timer expires - command is being run.
 */
var DebounceLoader = /** @class */ (function () {
    function DebounceLoader(command, timeout) {
        if (timeout === void 0) { timeout = 3000; }
        this.identityCheck = {};
        this.isWaiting = false;
        this.executor = new Executor(command);
        this.timeout = timeout;
    }
    Object.defineProperty(DebounceLoader.prototype, "isRunning", {
        get: function () {
            return this.executor.isRunning;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebounceLoader.prototype, "isActive", {
        get: function () {
            return this.isRunning || this.isWaiting;
        },
        enumerable: true,
        configurable: true
    });
    DebounceLoader.prototype.run = function () {
        var _this = this;
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        this.isWaiting = true;
        var identityKey = this.registerIdentity();
        setTimeout(function () {
            if (!_this.checkIdentity(identityKey)) {
                return;
            }
            _this.isWaiting = false;
            (_a = _this.executor).run.apply(_a, parameters);
            var _a;
        }, this.timeout);
    };
    DebounceLoader.prototype.reset = function () {
        this.isWaiting = false;
        this.identityCheck = {};
    };
    DebounceLoader.prototype.registerIdentity = function () {
        this.identityCheck = {};
        return this.identityCheck;
    };
    DebounceLoader.prototype.checkIdentity = function (key) {
        return this.identityCheck === key;
    };
    return DebounceLoader;
}());

/**
 * Runs command on timeout.
 * Don't forget to stop it or executor would run indefinitely.
 */
var RepeatLoader = /** @class */ (function () {
    function RepeatLoader(command, time) {
        this.time = 100;
        this.id = null;
        this.command = command;
        this.time = time;
    }
    RepeatLoader.prototype.start = function () {
        if (!this.id) {
            this.id = setInterval(this.command, this.time);
        }
    };
    RepeatLoader.prototype.stop = function () {
        if (this.id) {
            clearInterval(this.id);
        }
        this.id = null;
    };
    return RepeatLoader;
}());

var InfiniteLoader = /** @class */ (function () {
    // Is currently running from 0 pointer
    function InfiniteLoader(run, perStep) {
        if (perStep === void 0) { perStep = 20; }
        var _this = this;
        this.items = [];
        this.isFinished = false;
        this.isRefreshing = false;
        this.perStep = 20; // number of items to load
        this.pointer = 0;
        // Means no runs were executed
        this.isFresh = true;
        this.executor = new LadderExecutor(function (refresh) {
            if (refresh === void 0) { refresh = false; }
            return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.runRequest(run, refresh)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            }); });
        });
        this.perStep = perStep;
    }
    Object.defineProperty(InfiniteLoader.prototype, "isRunning", {
        /**
         * Command from this executor is currently running.
         */
        get: function () {
            return this.executor.isRunning;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteLoader.prototype, "isEmpty", {
        /**
         * We tried to load, but list is empty
         * Is false when executor is loading or is fresh.
         */
        get: function () {
            if (this.executor.isRunning) {
                return false;
            }
            return this.isFinished && (this.items.length === 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteLoader.prototype, "isFull", {
        /**
         * We tried to load, and list is not empty
         * Is false when executor is loading or is fresh.
         */
        get: function () {
            if (this.isFresh) {
                return false;
            }
            if (this.executor.isRunning) {
                return false;
            }
            return !!this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads a bunch of items
     */
    InfiniteLoader.prototype.next = function () {
        this.executor.run();
    };
    /**
     * Refresh the list.
     */
    InfiniteLoader.prototype.refresh = function () {
        this.executor.run(true);
    };
    InfiniteLoader.prototype.runRequest = function (pointerRequest, refresh) {
        if (refresh === void 0) { refresh = false; }
        return __awaiter(this, void 0, void 0, function () {
            var result, exception_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.pointer === 0) {
                            refresh = true;
                        }
                        if (refresh) {
                            this.pointer = 0;
                            this.isFresh = true;
                            this.isRefreshing = true;
                            this.isFinished = false;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, pointerRequest(this.pointer, this.perStep)];
                    case 2:
                        result = _a.sent();
                        if (!Array.isArray(result)) {
                            console.warn('InfiniteLoader function must return array');
                            return [2 /*return*/];
                        }
                        if (result.length < this.perStep) {
                            this.isFinished = true;
                        }
                        this.applyNew(result);
                        this.pointer = this.pointer + this.perStep;
                        this.isFresh = false;
                        return [3 /*break*/, 5];
                    case 3:
                        exception_1 = _a.sent();
                        this.isFinished = true;
                        throw exception_1;
                    case 4:
                        this.isRefreshing = false;
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    InfiniteLoader.prototype.applyNew = function (items) {
        if (this.isFresh) {
            this.items = items;
            return;
        }
        this.items = this.items.concat(items);
    };
    return InfiniteLoader;
}());

var AsyncHelpers = /** @class */ (function () {
    function AsyncHelpers() {
    }
    AsyncHelpers.sleep = function (ms) {
        return new Promise(function (resolve) { return setTimeout(resolve, ms); });
    };
    return AsyncHelpers;
}());

var RetrierExecutor = /** @class */ (function () {
    function RetrierExecutor(command, timeout, maxTime) {
        if (timeout === void 0) { timeout = 100; }
        if (maxTime === void 0) { maxTime = 1000; }
        this.iterationCount = 0;
        this.command = command;
        this.timeout = timeout;
        this.maxTime = maxTime;
    }
    /**
     * Shortcut to use executor functionally.
     */
    RetrierExecutor.waitUntil = function (command, timeout, maxTime) {
        return __awaiter(this, void 0, void 0, function () {
            var executor;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        executor = new RetrierExecutor(command, timeout, maxTime);
                        return [4 /*yield*/, executor.run()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(RetrierExecutor.prototype, "timeElapsed", {
        get: function () {
            return this.timeout * this.iterationCount;
        },
        enumerable: true,
        configurable: true
    });
    RetrierExecutor.prototype.takesTooLong = function () {
        return this.timeElapsed > this.maxTime;
    };
    RetrierExecutor.prototype.run = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.iterationCount = 0;
                        result = this.command();
                        _a.label = 1;
                    case 1:
                        if (!!result) return [3 /*break*/, 3];
                        return [4 /*yield*/, AsyncHelpers.sleep(this.timeout)];
                    case 2:
                        _a.sent();
                        this.iterationCount++;
                        if (this.takesTooLong()) {
                            throw new Error("Max time (" + this.maxTime + ") elapsed.");
                        }
                        result = this.command();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return RetrierExecutor;
}());

/**
 * Generate an array with sequence of numbers
 */
function range(start, end) {
    var length = (end - start);
    return Array(length).fill(0).map(function (item, index) { return start + index; });
}
var PointerRequestFactory = /** @class */ (function () {
    function PointerRequestFactory() {
    }
    PointerRequestFactory.getPointerRequest = function (timeout) {
        if (timeout === void 0) { timeout = 100; }
        return function (pointer, perStep) {
            return new Promise(function (resolve) {
                setTimeout(function () {
                    resolve(range(pointer, pointer + perStep));
                }, timeout);
            });
        };
    };
    return PointerRequestFactory;
}());

var InfiniteLoaderFactory = /** @class */ (function () {
    function InfiniteLoaderFactory() {
    }
    /**
     * Infinite loader generating a list of numbers by tens
     */
    InfiniteLoaderFactory.createNumberedList = function (timeout) {
        if (timeout === void 0) { timeout = 300; }
        var pointerRequest = PointerRequestFactory.getPointerRequest(timeout);
        return new InfiniteLoader(pointerRequest, 10);
    };
    return InfiniteLoaderFactory;
}());

/**
 * This executor keeps state of last result
 */
var StatefulExecutor = /** @class */ (function (_super) {
    __extends(StatefulExecutor, _super);
    function StatefulExecutor(command, state) {
        if (state === void 0) { state = null; }
        var _this = _super.call(this, command) || this;
        _this.state = state;
        return _this;
    }
    StatefulExecutor.createAndRun = function (command, state) {
        if (state === void 0) { state = null; }
        var executor = new StatefulExecutor(command, state);
        executor.run();
        return executor;
    };
    /**
     * Run command and cache promise.
     */
    StatefulExecutor.prototype.run = function () {
        var _this = this;
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        var promise = _super.prototype.run.apply(this, parameters);
        promise.then(function (result) {
            _this.state = result;
        });
        return promise;
    };
    return StatefulExecutor;
}(Executor));

export { CacheExecutor, DebounceLoader, Executor, InfiniteLoader, InfiniteLoaderFactory, LadderExecutor, RepeatLoader, RetrierExecutor, StatefulExecutor };
